/**
 * ========================================
 * SHOPIFY TO GOOGLE SHEETS SYNC 
 * Sincroniza √≥rdenes y clientes desde Shopify
 * SOLO actualiza o agrega, NUNCA duplica ni pisa datos
 * ========================================
 */

// ============================================
// CONFIGURACI√ìN PRINCIPAL
// ============================================

function getConfiguration() {
    const scriptProperties = PropertiesService.getScriptProperties();
    const storeName = scriptProperties.getProperty('SHOPIFY_STORE_NAME');
    const apiToken = scriptProperties.getProperty('SHOPIFY_API_TOKEN');

    if (!storeName || !apiToken) {
        throw new Error('Faltan credenciales de Shopify. Configura SHOPIFY_STORE_NAME y SHOPIFY_API_TOKEN en las propiedades del script.');
    }

    return {
        storeName: storeName,
        apiToken: apiToken,
        spreadsheetId: SpreadsheetApp.getActiveSpreadsheet().getId(),
        apiVersion: '2024-10'
    };
}

// ============================================
// FUNCI√ìN PRINCIPAL
// ============================================

function runShopifySync() {
    try {
        Logger.log('=== INICIANDO SINCRONIZACI√ìN SHOPIFY ===');
        const startTime = new Date();

        // 1. Cargar configuraci√≥n
        const config = getConfiguration();
        Logger.log(`Tienda: ${config.storeName}`);

        // 2. Generar los rangos de fechas para cada mes de 2025 hasta hoy
        const dateRanges = generateMonthlyDateRanges();
        Logger.log(`Rangos de fechas generados: ${dateRanges.length} meses`);

        // 3. Procesar √≥rdenes para cada rango de fechas
        let totalOrders = 0;
        let ordersUpdated = 0;
        let ordersAdded = 0;

        for (const range of dateRanges) {
            Logger.log(`\n--- Procesando √≥rdenes para ${range.monthName} ---`);
            const result = fetchAndProcessOrdersForMonth(config, range);
            totalOrders += result.total;
            ordersUpdated += result.updated;
            ordersAdded += result.added;
        }

        // 4. Una vez terminado, procesar todos los clientes
        Logger.log('\n--- Todas las √≥rdenes procesadas. Iniciando extracci√≥n de clientes ---');
        const customerResult = fetchAndProcessCustomers(config);

        const endTime = new Date();
        const duration = (endTime - startTime) / 1000;

        Logger.log('\n=== SINCRONIZACI√ìN COMPLETADA EXITOSAMENTE ===');
        Logger.log(`√ìRDENES - Total procesadas: ${totalOrders} | Actualizadas: ${ordersUpdated} | Nuevas: ${ordersAdded}`);
        Logger.log(`CLIENTES - Total procesados: ${customerResult.total} | Actualizados: ${customerResult.updated} | Nuevos: ${customerResult.added}`);
        Logger.log(`Tiempo total: ${Math.round(duration)} segundos`);

        // Mostrar mensaje de √©xito (solo si se ejecuta desde Sheets)
        showMessage(
            'Sincronizaci√≥n completada',
            `‚úì √ìRDENES: ${ordersAdded} nuevas, ${ordersUpdated} actualizadas\n‚úì CLIENTES: ${customerResult.added} nuevos, ${customerResult.updated} actualizados\n\nTiempo: ${Math.round(duration)}s`
        );

        return {
            success: true,
            orders: { total: totalOrders, updated: ordersUpdated, added: ordersAdded },
            customers: { total: customerResult.total, updated: customerResult.updated, added: customerResult.added },
            duration: Math.round(duration)
        };

    } catch (error) {
        Logger.log(`ERROR CR√çTICO: ${error.message}`);
        Logger.log(error.stack);

        showMessage(
            'Error en sincronizaci√≥n',
            `Hubo un error: ${error.message}\n\nRevisa los logs para m√°s detalles.`
        );

        throw error;
    }
}

// ============================================
// GENERACI√ìN DE RANGOS DE FECHAS
// ============================================

function generateMonthlyDateRanges() {
    const months = [];
    const year = 2025;
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();

    if (currentYear < year) {
        Logger.log('A√∫n no es 2025. No hay datos para procesar.');
        return [];
    }

    const maxMonth = (currentYear === year) ? currentMonth : 11;

    for (let month = 0; month <= maxMonth; month++) {
        const startDate = new Date(year, month, 1);
        const endDate = new Date(year, month + 1, 0, 23, 59, 59);
        const finalEndDate = (endDate > now) ? now : endDate;

        months.push({
            start: startDate.toISOString(),
            end: finalEndDate.toISOString(),
            monthKey: `${year}-${(month + 1).toString().padStart(2, '0')}`,
            monthName: startDate.toLocaleString('es-ES', { month: 'long', year: 'numeric' })
        });
    }

    return months;
}

// ============================================
// FUNCIONES DE OBTENCI√ìN DE DATOS (API)
// ============================================

function fetchAllPaginatedResults(initialUrl, config, resourceType = 'orders') {
    let allItems = [];
    let nextUrl = initialUrl;
    let pageCount = 0;

    const options = {
        'method': 'get',
        'headers': {
            'X-Shopify-Access-Token': config.apiToken,
            'Content-Type': 'application/json'
        },
        'muteHttpExceptions': true
    };

    // Espera inicial antes de la primera p√°gina (como en n8n)
    if (resourceType === 'orders') {
        Logger.log(`  Esperando 3 segundos antes de obtener √≥rdenes (rate limit)...`);
        Utilities.sleep(3000);
    }

    while (nextUrl) {
        pageCount++;
        Logger.log(`  Obteniendo p√°gina ${pageCount}...`);

        try {
            const response = UrlFetchApp.fetch(nextUrl, options);
            const responseCode = response.getResponseCode();

            if (responseCode !== 200) {
                Logger.log(`  ERROR en API (c√≥digo ${responseCode}): ${response.getContentText()}`);
                break;
            }

            const data = JSON.parse(response.getContentText());
            const resourceKey = Object.keys(data)[0];

            if (data[resourceKey] && Array.isArray(data[resourceKey]) && data[resourceKey].length > 0) {
                allItems = allItems.concat(data[resourceKey]);
                Logger.log(`  ‚Üí ${data[resourceKey].length} items obtenidos (total acumulado: ${allItems.length})`);
            } else {
                Logger.log(`  ‚Üí P√°gina vac√≠a o sin datos`);
            }

            // Buscar Link header para paginaci√≥n (igual que n8n)
            const headers = response.getHeaders();
            const linkHeader = headers['Link'] || headers['link'] || headers['LINK'];
            nextUrl = null;

            if (linkHeader && typeof linkHeader === 'string') {
                const links = linkHeader.split(',');
                for (const link of links) {
                    const match = link.match(/<([^>]+)>\s*;\s*rel="next"/i);
                    if (match) {
                        nextUrl = match[1];
                        Logger.log(`  ‚Üí Hay m√°s p√°ginas. Siguiente URL encontrada.`);
                        break;
                    }
                }
            }

            // Espera entre p√°ginas (como en n8n: 0.5s para √≥rdenes, 0.5s para clientes)
            if (nextUrl) {
                Logger.log(`  Esperando 500ms antes de la siguiente p√°gina...`);
                Utilities.sleep(500);
            }

        } catch (e) {
            Logger.log(`  ERROR al obtener p√°gina: ${e.message}`);
            Logger.log(`  Stack: ${e.stack}`);
            break;
        }
    }

    Logger.log(`  ‚úì Total de items obtenidos: ${allItems.length} en ${pageCount} p√°gina(s)`);
    return allItems;
}

function fetchAndProcessOrdersForMonth(config, range) {
    try {
        // Par√°metros id√©nticos a n8n: status=any, financial_status=any, limit=50
        const initialUrl = `https://${config.storeName}.myshopify.com/admin/api/${config.apiVersion}/orders.json?status=any&financial_status=any&limit=50&created_at_min=${range.start}&created_at_max=${range.end}`;

        Logger.log(`  URL: ${initialUrl.substring(0, 100)}...`);
        const orders = fetchAllPaginatedResults(initialUrl, config, 'orders');

        if (orders.length === 0) {
            Logger.log(`  No se encontraron √≥rdenes para ${range.monthName}.`);
            return { total: 0, updated: 0, added: 0 };
        }

        Logger.log(`  Procesando ${orders.length} √≥rdenes...`);
        const processedData = processShopifyOrders(orders, range.monthKey);
        const result = writeDataToSheet('Orders_Data', processedData, 0);

        return { total: orders.length, updated: result.updated, added: result.added };

    } catch (error) {
        Logger.log(`  ERROR procesando √≥rdenes de ${range.monthName}: ${error.message}`);
        throw error;
    }
}

function fetchAndProcessCustomers(config) {
    try {
        // Espera de 2 segundos antes de obtener clientes (como en n8n)
        Logger.log('  Esperando 2 segundos antes de obtener clientes...');
        Utilities.sleep(2000);

        const startDate = '2025-01-01T00:00:00Z';
        // L√≠mite de 250 como en n8n para clientes
        const initialUrl = `https://${config.storeName}.myshopify.com/admin/api/${config.apiVersion}/customers.json?limit=250&created_at_min=${startDate}`;

        Logger.log(`  URL: ${initialUrl.substring(0, 100)}...`);
        const customers = fetchAllPaginatedResults(initialUrl, config, 'customers');

        if (customers.length === 0) {
            Logger.log('  No se encontraron nuevos clientes.');
            return { total: 0, updated: 0, added: 0 };
        }

        Logger.log(`  Procesando ${customers.length} clientes...`);
        const processedData = processShopifyCustomers(customers);
        const result = writeDataToSheet('Customers_Data', processedData, 0);

        return { total: customers.length, updated: result.updated, added: result.added };

    } catch (error) {
        Logger.log(`  ERROR procesando clientes: ${error.message}`);
        throw error;
    }
}

// ============================================
// PROCESAMIENTO DE DATOS
// ============================================

function processShopifyOrders(orders, monthKey) {
    // Headers id√©nticos a n8n
    const headers = [
        'order_id',
        'order_name',
        'order_number',
        'created_at',
        'processed_at',
        'month_key',
        'financial_status',
        'fulfillment_status',
        'currency',
        'total_price',
        'subtotal_price',
        'total_tax',
        'total_discounts',
        'total_bags',
        'total_kilos',
        'customer_id',
        'customer_email',
        'customer_first_name',
        'customer_last_name',
        'shipping_city',
        'shipping_province',
        'shipping_country',
        'line_items_count',
        'product_titles'
    ];

    const dataRows = orders.map(order => {
        const lineItems = order.line_items || [];

        // Calcular total de bolsas y kilos (igual que n8n)
        const totalBags = lineItems.reduce((sum, item) => sum + (item.quantity || 0), 0);
        const totalKilos = lineItems.reduce((sum, item) => {
            const grams = item.grams || 0;
            const quantity = item.quantity || 0;
            return sum + (grams * quantity / 1000);
        }, 0);

        // Extraer t√≠tulos de productos (igual que n8n)
        const productTitles = lineItems
            .map(item => item.title)
            .filter(title => title)
            .join(' | ');

        // Funci√≥n auxiliar para n√∫meros seguros
        const safeNumber = (value) => {
            const num = parseFloat(value || 0);
            return isNaN(num) ? 0 : num;
        };

        return [
            order.id ? String(order.id) : '',
            order.name || '',
            order.order_number || '',
            order.created_at || '',
            order.processed_at || '',
            monthKey,
            order.financial_status || '',
            order.fulfillment_status || '',
            order.currency || '',
            safeNumber(order.total_price),
            safeNumber(order.subtotal_price),
            safeNumber(order.total_tax),
            safeNumber(order.total_discounts),
            totalBags,
            Math.round(totalKilos * 100) / 100,
            order.customer && order.customer.id ? String(order.customer.id) : '',
            order.customer && order.customer.email ? order.customer.email : '',
            order.customer && order.customer.first_name ? order.customer.first_name : '',
            order.customer && order.customer.last_name ? order.customer.last_name : '',
            order.shipping_address && order.shipping_address.city ? order.shipping_address.city : '',
            order.shipping_address && order.shipping_address.province ? order.shipping_address.province : '',
            order.shipping_address && order.shipping_address.country ? order.shipping_address.country : '',
            lineItems.length,
            productTitles
        ];
    });

    return [headers, ...dataRows];
}

function processShopifyCustomers(customers) {
    // Headers id√©nticos a n8n
    const headers = [
        'customer_id',
        'email',
        'first_name',
        'last_name',
        'orders_count',
        'total_spent',
        'created_at',
        'updated_at',
        'days_since_creation',
        'days_since_last_order',
        'accepts_marketing',
        'state',
        'currency',
        'customer_segment',
        'address_city',
        'address_province',
        'address_country'
    ];

    const now = new Date();

    const dataRows = customers.map(customer => {
        const ordersCount = customer.orders_count || 0;

        // Segmentaci√≥n id√©ntica a n8n
        let segment = 'New';
        if (ordersCount >= 3) segment = 'Loyal';
        else if (ordersCount >= 2) segment = 'Repeat';
        else if (ordersCount === 1) segment = 'One-time';

        // Calcular d√≠as desde creaci√≥n y √∫ltima orden (igual que n8n)
        let daysSinceCreation = null;
        let daysSinceLastOrder = null;

        if (customer.created_at) {
            try {
                const createdDate = new Date(customer.created_at);
                daysSinceCreation = Math.floor((now - createdDate) / (1000 * 60 * 60 * 24));
            } catch (e) {
                daysSinceCreation = null;
            }
        }

        if (customer.updated_at) {
            try {
                const updatedDate = new Date(customer.updated_at);
                daysSinceLastOrder = Math.floor((now - updatedDate) / (1000 * 60 * 60 * 24));
            } catch (e) {
                daysSinceLastOrder = null;
            }
        }

        const mainAddress = (customer.addresses && customer.addresses.length > 0) ? customer.addresses[0] : {};

        return [
            customer.id ? String(customer.id) : '',
            customer.email || '',
            customer.first_name || '',
            customer.last_name || '',
            ordersCount,
            parseFloat(customer.total_spent || 0),
            customer.created_at || '',
            customer.updated_at || '',
            daysSinceCreation !== null ? daysSinceCreation : '',
            daysSinceLastOrder !== null ? daysSinceLastOrder : '',
            customer.accepts_marketing || false,
            customer.state || '',
            customer.currency || '',
            segment,
            mainAddress.city || '',
            mainAddress.province || '',
            mainAddress.country || ''
        ];
    });

    return [headers, ...dataRows];
}

// ============================================
// ESCRITURA INTELIGENTE EN GOOGLE SHEETS
// SOLO ACTUALIZA O AGREGA - NUNCA DUPLICA
// ============================================

function writeDataToSheet(sheetName, data, primaryKeyColumnIndex) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = spreadsheet.getSheetByName(sheetName);

    if (!sheet) {
        sheet = spreadsheet.insertSheet(sheetName);
        Logger.log(`  Pesta√±a "${sheetName}" creada.`);
    }

    const headers = data[0];
    const dataRows = data.slice(1);

    if (dataRows.length === 0) {
        Logger.log(`  No hay datos para escribir en "${sheetName}".`);
        return { updated: 0, added: 0 };
    }

    // Si la hoja est√° vac√≠a, escribir headers y datos
    if (sheet.getLastRow() === 0) {
        sheet.getRange(1, 1, data.length, headers.length).setValues(data);
        Logger.log(`  "${sheetName}": ${data.length - 1} filas iniciales escritas.`);
        return { updated: 0, added: data.length - 1 };
    }

    // Leer datos existentes
    const lastRow = sheet.getLastRow();
    const existingData = sheet.getRange(1, 1, lastRow, headers.length).getValues();
    const existingHeaders = existingData[0];

    // Verificar que headers coincidan
    if (JSON.stringify(existingHeaders) !== JSON.stringify(headers)) {
        Logger.log(`  ADVERTENCIA: Headers no coinciden en "${sheetName}". Reescribiendo hoja completa.`);
        sheet.clear();
        sheet.getRange(1, 1, data.length, headers.length).setValues(data);
        return { updated: 0, added: data.length - 1 };
    }

    // Crear mapa de ID existente ‚Üí √≠ndice de fila
    const existingIdMap = new Map();
    for (let i = 1; i < existingData.length; i++) {
        const id = String(existingData[i][primaryKeyColumnIndex]);
        if (id && id !== '') {
            existingIdMap.set(id, i + 1); // Fila en Sheet (1-based, +1 por header)
        }
    }

    Logger.log(`  IDs existentes en "${sheetName}": ${existingIdMap.size}`);

    // Procesar cada fila de datos nuevos
    let updatedCount = 0;
    let addedCount = 0;
    const rowsToAppend = [];

    for (const row of dataRows) {
        const id = String(row[primaryKeyColumnIndex]);

        if (!id || id === '') {
            Logger.log(`  ADVERTENCIA: Fila sin ID v√°lido, se omite.`);
            continue;
        }

        if (existingIdMap.has(id)) {
            // ACTUALIZAR fila existente
            const rowIndex = existingIdMap.get(id);

            // Comparar si los datos son diferentes antes de actualizar
            const existingRow = existingData[rowIndex - 1];
            const isDifferent = !arraysEqual(existingRow, row);

            if (isDifferent) {
                sheet.getRange(rowIndex, 1, 1, row.length).setValues([row]);
                updatedCount++;
            }
            // Si son iguales, no hace nada (ignora)

        } else {
            // AGREGAR nueva fila
            rowsToAppend.push(row);
        }
    }

    // Agregar todas las nuevas filas de una vez al final
    if (rowsToAppend.length > 0) {
        const startRow = sheet.getLastRow() + 1;
        sheet.getRange(startRow, 1, rowsToAppend.length, headers.length).setValues(rowsToAppend);
        addedCount = rowsToAppend.length;
    }

    Logger.log(`  "${sheetName}": ${updatedCount} actualizadas, ${addedCount} nuevas agregadas.`);

    return { updated: updatedCount, added: addedCount };
}

// Funci√≥n auxiliar para comparar arrays
function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
        if (String(a[i]) !== String(b[i])) return false;
    }
    return true;
}

// ============================================
// FUNCI√ìN DE PRUEBA
// ============================================

function testConnection() {
    try {
        Logger.log('=== PRUEBA DE CONEXI√ìN SHOPIFY ===\n');

        Logger.log('1. Verificando configuraci√≥n...');
        const config = getConfiguration();
        Logger.log(`   ‚úì Tienda: ${config.storeName}`);
        Logger.log(`   ‚úì Token: ${config.apiToken.substring(0, 10)}...`);
        Logger.log(`   ‚úì Versi√≥n API: ${config.apiVersion}`);

        Logger.log('\n2. Probando conexi√≥n con Shopify API...');
        const testUrl = `https://${config.storeName}.myshopify.com/admin/api/${config.apiVersion}/shop.json`;

        const options = {
            'method': 'get',
            'headers': {
                'X-Shopify-Access-Token': config.apiToken,
                'Content-Type': 'application/json'
            },
            'muteHttpExceptions': true
        };

        const response = UrlFetchApp.fetch(testUrl, options);
        const responseCode = response.getResponseCode();

        if (responseCode === 200) {
            const shopData = JSON.parse(response.getContentText());
            Logger.log('   ‚úì Conexi√≥n exitosa!');
            Logger.log(`   ‚úì Tienda: ${shopData.shop.name}`);
            Logger.log(`   ‚úì Dominio: ${shopData.shop.domain}`);
            Logger.log(`   ‚úì Email: ${shopData.shop.email}`);
        } else {
            Logger.log(`   ‚úó Error de conexi√≥n (c√≥digo ${responseCode})`);
            Logger.log(`   Respuesta: ${response.getContentText()}`);
            throw new Error(`No se pudo conectar con Shopify (c√≥digo ${responseCode})`);
        }

        Logger.log('\n3. Probando obtenci√≥n de √≥rdenes...');
        const ordersUrl = `https://${config.storeName}.myshopify.com/admin/api/${config.apiVersion}/orders.json?limit=1&status=any`;
        const ordersResponse = UrlFetchApp.fetch(ordersUrl, options);

        if (ordersResponse.getResponseCode() === 200) {
            const ordersData = JSON.parse(ordersResponse.getContentText());
            Logger.log(`   ‚úì Se pueden obtener √≥rdenes (encontradas: ${ordersData.orders.length})`);
            if (ordersData.orders.length > 0) {
                Logger.log(`   ‚úì Ejemplo: Orden #${ordersData.orders[0].name}`);
            }
        }

        Logger.log('\n4. Verificando acceso a Google Sheets...');
        const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
        Logger.log(`   ‚úì Spreadsheet: ${spreadsheet.getName()}`);
        Logger.log(`   ‚úì ID: ${spreadsheet.getId()}`);

        Logger.log('\n=== PRUEBA COMPLETADA EXITOSAMENTE ===');
        Logger.log('El script est√° listo. Ejecuta runShopifySync() para sincronizar.');

        showMessage(
            'Prueba exitosa ‚úì',
            'La conexi√≥n con Shopify funciona correctamente.\n\nYa puedes ejecutar la sincronizaci√≥n completa.'
        );

        return { success: true };

    } catch (error) {
        Logger.log(`\n‚úó ERROR EN LA PRUEBA: ${error.message}`);
        Logger.log(error.stack);

        showMessage(
            'Error en la prueba',
            `Hubo un problema:\n\n${error.message}\n\nRevisa los logs para m√°s detalles.`
        );

        throw error;
    }
}

// ============================================
// FUNCIONES AUXILIARES
// ============================================

function showMessage(title, message) {
    try {
        SpreadsheetApp.getUi().alert(title, message, SpreadsheetApp.getUi().ButtonSet.OK);
    } catch (e) {
        Logger.log(`\n[MENSAJE] ${title}: ${message}`);
    }
}

// ============================================
// MEN√ö PERSONALIZADO
// ============================================

function onOpen() {
    try {
        const ui = SpreadsheetApp.getUi();
        ui.createMenu('üõí Shopify Sync')
            .addItem('‚ñ∂Ô∏è Ejecutar sincronizaci√≥n', 'runShopifySync')
            .addItem('üîß Probar conexi√≥n', 'testConnection')
            .addSeparator()
            .addItem('üìã Ver logs', 'showLogsUrl')
            .addToUi();
    } catch (e) {
        Logger.log('No se pudo crear el men√∫ (ejecutado desde editor)');
    }
}

function showLogsUrl() {
    const url = `https://script.google.com/home/projects/${ScriptApp.getScriptId()}/executions`;
    showMessage('Ver logs', `Abre esta URL para ver los logs:\n\n${url}`);
}